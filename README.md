# CPU Gregorian Chant

![Welcome Gif](/assets/readme/welcome.GIF)

CPU Gregorian Chant is a web application that procedurally generates Gregorian chant. It generates music in all eight Gregorian modes and provides theoretical information so users can hear, see, and read about the differences in Gregorian modes. The application includes articles on notation, modes, and history as well as a bibliography.

**Link to site:** https://cpu-gregorian-chant.com/

## How it's made

**Tech used:**
<br>
• [HTML](https://html.spec.whatwg.org/multipage/)
<br>
• [CSS](https://www.w3.org/Style/CSS/)
<br>
• [JavaScript](https://262.ecma-international.org/) and various libraries
<br>
• [Python](https://www.python.org/)
<br>
• [Pixelorama](https://orama-interactive.itch.io/pixelorama)

**Libraries used:**
<br>
• [exsurge.js](https://github.com/frmatthew/exsurge) for the rendering of Gregorian chant notation
<br>
• [Tone.js](https://tonejs.github.io/) for the production of sound
<br>
• [Pyscript](https://pyscript.net/) for the communication of Python and Javascript
<br>
• [Bootstrap](https://getbootstrap.com/)/[jQuery](https://jquery.com/) for the functionality of the buttons

### Music Generation
<details><summary>Read More</summary>
I believe it is important to note that the music is not generated by "AI". It is generated through an algorithm written in Python. To describe the process at a very high level — the music generates as a string of [gabc](https://gregorio-project.github.io/gabc/), a notation which uses ASCII characters to create Gregorian chant scores. After the gabc string has generated, it is parsed, and another string is created to be used by Tone.js. These strings are then passed from Python to JavaScript where they are processed by exsurge.js and Tone.js to render notation and produce sound, respectively. Examples of potential strings are given below.

gabc: (c4)(h)(gd)(e)(dh)(j)(k)(i)(h)(i)(g)(hj)(i)(g)(e.)(::)

Tone: A3 G3 D3 E3 D3 A3 C4 D4 B3 A3 B3 G3 A3 C4 B3 G3 E3. |

<!-- Now for a discussion of the more intricate details of the process: -->

There are two core components of Gregorian chant: form and mode. Form can be defined as the structure of a musical composition. Mode, a musical scale and its characteristic melodic and harmonic qualities. Before music can be "composed", the user must select a form and mode. The selected formal and modal information is stored in JS, and, after the compose button is clicked, passes from JS to Python for generation.

The length of compositions is dependent on the form selected. Syllabic compositions have four sections, neumatic have three, and melismatic have two. These numbers are arbitrary and do not in any way reflect the formal structure of real chants. The number of sections decrease with each form because of their neumatic variety. Songs with many neumes (neumatic and melismatic) will be longer than those with few or no neumes (syllabic) due to nature of the algorithm. The length of each section varies, the primary determinant of which being the number of "sectionelles" (my term) it contains. Sections are most likely to consist of one sectionelle, but may have two, which are separated by a breath mark.

The modal component of the generative algorithm concerns the notes themselves, the backbone of which the is a [Markov chain](https://en.wikipedia.org/wiki/Markov_chain). Using Markov chains to generate Gregorian chant involves creating datasets of notes from real Gregorian songs (one for each mode) entered in order of their appearance. Below is the dataset for the first mode, the Dorian mode.

![Dorian dataset](/assets/readme/dorian-data.png)

With this set, a collection of "bigrams" is generated and stored in a separate array. For this dataset, the bigrams will be df, fg, gf, fe, ed, etc. This array of bigrams will be used to find the next note in the sequence as the music generates.

The music generates one section and, subsequently, one sectionelle at a time, within which one note is written at a time. To begin the sequence, the number of sectionelles within the section (1 or 2) is defined at random. Then, the length of the current sectionelle is randomly determined. After these factors are decided, the following occurs for each sectionelle: a note is chosen at random to be the first note (based on a dataset of genuine Gregorian starting notes, mode specific). This note is the "current note". To generate the following note, the "current note" is passed to the "predict_next_state" function, which finds all bigrams beginning with the current note and calculates probabilities based on the second note. For example, if the current note is d and the available bigrams are df, da, df, and de, there will be a 50% chance to return f, a 25% chance to return a, and a 25% chance to return e. The function selects a note based on these probabilities and returns it. Whichever note returns is appended the string and becomes the current note. The process repeats until the note string reaches the current sectionelle's defined length. Once the string reaches this length, a "closing note" is appended to conclude the sectionelle. If the current sectionelle is not the last, the closing note will be the closest note to the current note which is present in the selected mode's array of closing notes (based on a dataset of genuine Gregorian closing notes, mode specific). After this, the process repeats for the next sectionelle or section. However, if writing the final sectionelle of the chant, the closing note will be the selected mode's "finalis", the note which is always the final note in any chant of a particular mode.

Once the music has generated, another algorithm reads the generated string and creates a separate string to be used by Tone.js. Both strings are then passed from Python to JavaScript, and the score is rendered.
</details>

<details><summary><h3>The Monks</h3></summary>
The monks were designed in Pixelorama. While I liked their earliest version, it had some issues. The dimensions of their heads were 5x6 pixels, which severely limits detail potential. The greatest issue to emerge from this limitation is the mouth. Their mouth was 1x1 pixel, and animating it to sing or speak had no good solution. I came up with two options. I could remove the mouth entirely when they aren't singing and have it appear when they sing, or I could expand the mouth and chin down one pixel when they sing. As you can imagine, all of these animations become even worse when animating to speak. It was apparrent that I needed more pixels.
<br><br>

![Early Monks](/assets/readme/early-monks.png) | ![Early Monks - Mouths Open](/assets/readme/early-monks-waaah.png)
:-------------------------:|:-------------------------:
an early version of the monks | an experimental singing version of the monks

After some experimentation, I decided to increase the pixel count on the heads (and legs!) only, leaving the robes identical to the earliest model. I believe the wide black outlines conveys a sort of thickness, and the stylistic inconsistencies between the heads and the robes meshes very well.

![Final Monks](/assets/readme/final-monks.png)
:--:
The final version of the monks.

Some find
</details>

### Speech Box
The speech box presented a surprising challenge. Two factors primarily contributed to this challenge — the "typewriter" effect, and the colored terms that display a definition when hovered over.
<br><br>
The typewriter effect is, in essence, simple — add characters individually on a timer which determines the interval of addition. Where this gets tricky is coloring the terms and making them unique hoverable elements. To color the terms, I stored the terms in three separate arrays, each containing the green, red, and blue terms. When the monks must recite a phrase, a function called "find_important" parses the phrase and finds the indices where colored text begins and ends. After this, the "typewriter" function is called, and the textual rendering begins. The text is rendered one character at a time, and, when it reaches one of the "important indices", it enters a sort of sub-function which creates a new `<span>`, assigns it the appropriate class name for color, and appends characters until the word is complete. To make the element hoverable, the event "mousemove" and "mouseleave" are added to each colored span, and, upon hovering, the respective term is passed into the "blue_text" function to display a small box containing the term and definition at the position of the cursor. It sounds simple enough when I type it out, but I can assure you that it is **not**. There are many specific cases that must be accounted for, and making each unique element hoverable causes weird and frustrating side effects unless specific steps are taken . Like everything, the basics are easy, but perfection is hard.
<br><br>
One interesting component of the speech box is the use of a "ghost box" to correctly display the box in certain cases. Most of the time, the monks' speech will exceed one line. In this case, the box renders to the full extent and there are no problems. In a few cases, however, the speech does not exceed one line. Without modifications, this results in an uncentered box floating to the left. Bad. I couldn't simply align the text to the center (text-align: center), because the text, being rendered one character at a time, would render the first character at the center and expand in both directions. Worse. The answer was a "ghost box", an invisible box containing the complete speech text. This box would be centered, and its "left" property would be read in JS and applied to the speech box. This way, the typed speech could begin on the left side and remain centered over the monks' tonsures.

## Cross-browser functionality

The project uses two separate versions of exsurge. The reason for this is that one version, the one I developed with for nearly the entire development period, is very visually appealing and easy to work with, as the chant elements are perfectly spaced and each svg element has a very specific class name with the respective chant element (PorrectusFlexus, TorculusResupinus, etc.). The problem with this version is that the clefs do not render on Chromium-based browsers! I discovered this while presenting the project to the faculty panel at my university (luckily, no one could tell)! This issue is strange and perplexing, but I believe I know what causes this. The clef is defined last in the `<defs>` section of the svg, and that seems to be the source of this weird issue. I was unable to fix it, but another version of exsurge is fully compatible with all browsers, so detecting the user's browser and loading the appropriate version of exsurge seemed to be the simplest fix.

In the following paragraph, I will refer to the exsurge versions as version 1 (less compatible) and version 2 (more compatible).

Why didn't I opt to use this new, more compatible version of exsurge for all versions? There are a few reasons, one being that the specification of chant elements by class name allowed me to very easily display information on the hover of each chant element i.e. display "Porrectus Flexus: a four-note neume that is a porrectus with a low note at the end" when the user hovers over a porrectus flexus. This is possible on the alternate version, but it would require far more effort. Another reason is that version 1 is more visually appealing. The chant elements are flawlessly spaced, whereas the elements on version 2 are very condensed. The way that chant elements are classified in version 1 allows the complete neume (punctums and lines, accidentals, etc.) to illuminate together as the monks sing, whereas version 2 illuminates only the punctums and leaves neume lines the default black. Furthermore, there seems to be a design error with the displaying of a climacus (note with descending rhombi) in version 2. In most chant manuscripts, the first note of a climacus is presented as a virga, that is, a square note with a stem descending from the right side (see figure: exsurge version 1), but in version 2, the first note is displayed as a punctum (see figure: exsurge version 2). Exsurge version 2's powerful benefit of compatibility doesn't offset its negative traits, and I figured that it was best to use the superior but less compatible version of exsure for browsers that support it (Firefox and Safari).

![exsurge version 1 - less compatible](/assets/readme/exsurge-1.png) | ![exsurge version 2 - more compatible](/assets/readme/exsurge-2.png)
:-------------------------:|:-------------------------:
exsurge version 1 - less compatible | exsurge version 2 - more compatible

## Fonts

**Fonts**
<br>
• [Alagard](https://www.dafont.com/alagard.font)
<br>
• [IM Fell English](https://fonts.google.com/specimen/IM+Fell+English)
