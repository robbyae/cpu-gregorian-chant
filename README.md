# CPU Gregorian Chant

![Welcome Gif](/assets/readme/welcome.GIF)

CPU Gregorian Chant is a web application that procedurally generates Gregorian chant. It generates music in all eight Gregorian modes and provides theoretical information so users can hear, see, and read about the differences in Gregorian modes. The application includes articles on notation, modes and history as well as a bibliography.

**Link to site:** https://cpu-gregorian-chant.com/

## How it's made

**Tech used:**
<br>
• [HTML](https://html.spec.whatwg.org/multipage/)
<br>
• [CSS](https://www.w3.org/Style/CSS/)
<br>
• [JavaScript](https://262.ecma-international.org/) and various libraries
<br>
• [Python](https://www.python.org/)
<br>
• [Pixelorama](https://orama-interactive.itch.io/pixelorama)

**Libraries used:**
<br>
• [Exsurge.js](https://github.com/frmatthew/exsurge) for the rendering of Gregorian chant notation
<br>
• [Tone.js](https://tonejs.github.io/) for the production of sound
<br>
• [Pyscript](https://pyscript.net/) for the communication of Python and Javascript
<br>
• [Bootstrap](https://getbootstrap.com/)/[jQuery](https://jquery.com/) for the functionality of the buttons

**Music Generation**
<br>
I believe it is important to note that the music is not generated by "AI". It is generated through an algorithm written in Python by me. The backbone of this algorithm is a Markov chain, or, simply put, a process which predicts future outcomes based only on an object's current state. In generating Gregorian chant, this involves creating data sets (one for each mode) of notes taken from real Gregorian songs. Below is my data set for the first mode, called the Dorian mode.
![Dorian data set](/assets/readme/dorian-data.png)
Then, a set of "bigrams" is generated. For this data set, the bigrams will look like df, fg, gf, fe, ed, etc. 


**Speech Box**
<br>
The speech box presented one of the biggest challenges of the project. Two factors primarily contributed to this challenge — the "typewriter" effect and the colored terms that display a definition when hovered over.
<br><br>
The typewriter effect is, in essence, simple — add characters individually on a timer which determines the interval of addition. Where this gets tricky is coloring the terms and making them unique hoverable elements. To color the terms, I stored the terms in three separate arrays, each containing the green, red, and blue terms. When the monks must recite a phrase, a function called "find_important" parses the phrase and finds the indices where colored text begins and ends. After this, the "typewriter" function is called, and the textual rendering begins. The text is rendered one character at a time, and, when it reaches one of the "important indices", it enters a sort of sub-function which creates a new `<span>`, assigns it the appropriate class name for color, and appends characters until the word is complete. To make the element hoverable, the event "mousemove" and "mouseleave" are added to each colored span, and, upon hovering, the respective term is passed into the "blue_text" function to display a small box containing the term and definition at the position of the cursor. It sounds simple enough when I type it out, but I can assure you that it is **not**. There are many specific cases that must be accounted for, and making each unique element hoverable causes weird and frustrating side effects unless specific steps are taken . Like everything, the basics are easy, but perfection is hard.
<br><br>
One interesting component of the speech box is the use of a "ghost box" to correctly display the box in certain cases. Most of the time, the monks' speech will exceed one line. In this case, the box renders to the full extent and there are no problems. In a few cases, however, the speech does not exceed one line. Without modifications, this results in an uncentered box floating to the left. Bad. I couldn't simply align the text to the center (text-align: center), because the text, being rendered one character at a time, would render the first character at the center and expand in both directions. Worse. The answer was a "ghost box", an invisible box containing the complete speech text. This box would be centered, and its "left" property would be read in JS and applied to the speech box. This way, the typed speech could begin on the left side and remain centered over the monks' tonsures.

## Cross-browser functionality

The project uses two separate versions of exsurge. The reason for this is that one version, the one I developed with for nearly the entire development period, is very visually appealing and easy to work with, as the chant elements are perfectly spaced and each svg element has a very specific class name with the respective chant element (PorrectusFlexus, TorculusResupinus, etc.). The problem with this version is that the clefs do not render on Chromium-based browsers! I discovered this while presenting the project to the faculty panel at my university (luckily, no one could tell)! This issue is strange and perplexing, but I believe I know what causes this. The clef is defined last in the `<defs>` section of the svg, and that seems to be the source of this weird issue. I was unable to fix it, but another version of exsurge is fully compatible with all browsers, so detecting the user's browser and loading the appropriate version of exsurge seemed to be the simplest fix.

In the following paragraph, I will refer to the exsurge versions as version 1 (less compatible) and version 2 (more compatible).

Why didn't I opt to use this new, more compatible version of exsurge for all versions? There are a few reasons, one being that the specification of chant elements by class name allowed me to very easily display information on the hover of each chant element i.e. display "Porrectus Flexus: a four-note neume that is a porrectus with a low note at the end" when the user hovers over a porrectus flexus. This is possible on the alternate version, but it would require far more effort. Another reason is that version 1 is more visually appealing. The chant elements are flawlessly spaced, whereas the elements on version 2 are very condensed. The way that chant elements are classified in version 1 allows the complete neume (punctums and lines, accidentals, etc.) to illuminate together as the monks sing, whereas version 2 illuminates only the punctums and leaves neume lines the default black. Furthermore, there seems to be a design error with the displaying of a climacus (note with descending rhombi) in version 2. In most chant manuscripts, the first note of a climacus is presented as a virga, that is, a square note with a stem descending from the right side (see figure: exsurge version 1), but in version 2, the first note is displayed as a punctum (see figure: exsurge version 2). Exsurge version 2's powerful benefit of compatibility doesn't offset its negative traits, and I figured that it was best to use the superior but less compatible version of exsure for browsers that support it (Firefox and Safari).

![exsurge version 1 - less compatible](/assets/readme/exsurge-1.png) | ![exsurge version 2 - more compatible](/assets/readme/exsurge-2.png)
:-------------------------:|:-------------------------:
exsurge version 1 - less compatible | exsurge version 2 - more compatible

## Fonts

**Fonts**
<br>
• [Alagard](https://www.dafont.com/alagard.font)
<br>
• [IM Fell English](https://fonts.google.com/specimen/IM+Fell+English)
